#!/usr/bin/env node

import { promises as fs } from 'fs'
import path from 'path'

import { getArgValue, getHeaderArgs, isHelpRequested } from './utils'
import { showManual } from './manual'
import { getFiles } from './files'

// Helper function to generate namespace from file path (cross-platform)
const generateNamespaceFromPath = (filePath: string, projectName?: string): string => {
    const dir = path.dirname(filePath)
    
    // If project name is provided, construct namespace by finding the project name in the path
    // and using everything after it
    if (projectName) {
        // First, normalize the path to dots
        const normalizedDir = path.normalize(dir)
            .replace(/^\.[\\/]/, '') // Remove leading ./ or .\
            .replace(/[\\/]+/g, '.') // Convert all path separators to dots
        
        // Find the project name in the normalized path
        const projectIndex = normalizedDir.indexOf(projectName)
        if (projectIndex !== -1) {
            const pathAfterProject = normalizedDir.substring(projectIndex + projectName.length)
            // Clean up any leading dots
            const cleanPathAfterProject = pathAfterProject.replace(/^\.+/, '')
            return `${projectName}${cleanPathAfterProject ? '.' + cleanPathAfterProject : ''}`
        }
        
        // If project name not found in path, just prepend it
        return `${projectName}.${normalizedDir}`
    }
    
    // Normalize path separators and remove leading ./ or .\
    const normalizedDir = path.normalize(dir)
        .replace(/^\.[\\/]/, '') // Remove leading ./ or .\
        .replace(/[\\/]+/g, '.') // Convert all path separators to dots
    
    return normalizedDir
}

// Helper function to create dynamic config content based on GraphQL files (cross-platform)
const createDynamicConfig = (schemaUrl: string, graphqlFiles: string[], graphqlDir: string, projectName?: string, headers?: string[]): string => {
    let config = `# generated by agoda-graphql-csharp-generator
overwrite: true
schema: "${schemaUrl}"
`
    if (headers && headers.length > 0) {
        config += `headers:
`
        for (const header of headers) {
            const [key, value] = header.split(': ', 2)
            if (key && value) {
                const numValue = Number(value)
                if (!isNaN(numValue) && value.trim() === numValue.toString()) {
                    config += `    ${key}: ${numValue}
`
                } else {
                    config += `    ${key}: "${value}"
`
                }
            }
        }
    }
    
    config += `generates:
`
    
    // Generate shared types section first
    // Use the graphqlDir to determine both the output path and namespace
    
    // For output path, use the original graphqlDir
    const sharedTypesOutputFile = `${graphqlDir}/SharedTypes.generated.cs`
    const normalizedSharedTypesOutputFile = sharedTypesOutputFile.replace(/\\/g, '/')
    
    // For namespace, clean up the path and handle project name matching
    const cleanGraphqlDir = graphqlDir.replace(/^\.\//, '').replace(/[\/\\]/g, '.')
    let sharedTypesNamespace: string
    
    if (projectName) {
        // If project name is provided, find the matching part in the graphqlDir and use it + the rest
        const cleanGraphqlDirWithoutPrefix = cleanGraphqlDir.replace(/^(\.\.\/)+/, '').replace(/^\.\//, '')
        const projectNameDots = projectName.replace(/[\/\\]/g, '.')
        
        // Find where the project name appears in the clean path
        const projectIndex = cleanGraphqlDirWithoutPrefix.indexOf(projectNameDots)
        
        if (projectIndex !== -1) {
            // Use the project name + everything after it
            sharedTypesNamespace = cleanGraphqlDirWithoutPrefix.substring(projectIndex)
        } else {
            // If project name not found, use the full cleaned path as namespace
            sharedTypesNamespace = cleanGraphqlDirWithoutPrefix
        }
    } else {
        // Remove any relative path parts for namespace - make it generic
        sharedTypesNamespace = cleanGraphqlDir.replace(/^(\.\.\/)+/, '').replace(/^\.\//, '')
    }
    
    config += `    ${normalizedSharedTypesOutputFile}:
        documents:
`
    for (const graphqlFile of graphqlFiles) {
        const normalizedGraphqlFile = graphqlFile.replace(/\\/g, '/')
        config += `            - "${normalizedGraphqlFile}"
`
    }
    config += `        plugins:
            - "agoda-graphql-csharp-generator/shared-types"
        config:
            namespace: "${sharedTypesNamespace}"
`
    
    // Generate individual sections for each GraphQL file
    for (const graphqlFile of graphqlFiles) {
        // Create the output .generated.cs file path
        const outputFile = graphqlFile.replace(/\.graphql$/, '.generated.cs')
        
        // Generate namespace from the directory path with optional project name
        const namespace = generateNamespaceFromPath(graphqlFile, projectName)
        
        // Normalize paths for YAML config (always use forward slashes in YAML)
        const normalizedOutputFile = outputFile.replace(/\\/g, '/')
        const normalizedGraphqlFile = graphqlFile.replace(/\\/g, '/')
        
        // Add the generate section for this file
        config += `    ${normalizedOutputFile}:
        documents:
            - "${normalizedGraphqlFile}"
        plugins:
            - "agoda-graphql-csharp-generator/operation"
        config:
            namespace: "${namespace}"
`
    }
    
    return config
}

export const run = async (): Promise<void> => {
    const currentDir = process.cwd()
    
    if (isHelpRequested()) {
        showManual()
        process.exit(0)
    }

    const rawGraphqlDirectory = getArgValue('--graphql-dir')
    const schemaUrl = getArgValue('--schema-url')
    const graphqlProject = getArgValue('--graphql-project')
    const ymlOut = getArgValue('--yml-out')
    const headers = getHeaderArgs()

    if (!rawGraphqlDirectory || !schemaUrl || !graphqlProject) {
        console.error('Usage: script --graphql-dir <dir> --schema-url <url> --graphql-project <project-name> [--header <name:value>] [--yml-out <output-path>]')
        process.exit(1)
    }

    const outputConfigFilePath = ymlOut ? path.resolve(ymlOut) : path.join(currentDir, 'codegen.yml')

    console.log('raw graphql directory: ', rawGraphqlDirectory)
    console.log('graphql schema url: ', schemaUrl)
    console.log('graphql project: ', graphqlProject)
    if (ymlOut) {
        console.log('yml output path: ', outputConfigFilePath)
    }
    if (headers.length > 0) {
        console.log('headers: ', headers)
    }

    const graphqlFiles = await getFiles(rawGraphqlDirectory, '.graphql')
    
    if (graphqlFiles.length === 0) {
        console.log('No GraphQL files found in the specified directory')
        return
    }
    
    console.log(`Found ${graphqlFiles.length} GraphQL files:`)
    graphqlFiles.forEach(file => console.log(`  - ${file}`))

    try {
        console.log('Creating dynamic config content...')
        const dynamicConfigContent = createDynamicConfig(schemaUrl, graphqlFiles, rawGraphqlDirectory, graphqlProject, headers)

        const configFileName = path.basename(outputConfigFilePath)
        console.log(`Creating ${configFileName} at:`, outputConfigFilePath)
        await fs.writeFile(outputConfigFilePath, dynamicConfigContent, 'utf8')
        console.log(`Successfully created ${configFileName}`)
        
    } catch (error) {
        console.error('Error during GraphQL code generation:', error)
        throw error
    }

}

run().catch((err) => {
    console.error('Fatal error:', err)
    process.exit(1)
})
